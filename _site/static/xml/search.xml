<?xml version="1.0" encoding="utf-8"?>
<ul>
  <li>x86_64汇编指令add加法addrax,rbxrax=rax+rbxsub减法subrax,rbxrax=rax-rbximul乘法imulrax,rbx;rax=rax*rbximulrbx;只有一个操作数时另一个操作数是rax,高位保存在rdx,低位保存在raxdiv除法divrcx;rax=rdx/rcx,rdx=rdx/rcx被除数在rdx和rax,高位和低位。除数是指定操作数商保存在rax余数保存在rdx浮点数的运算完全不同于整数，从寄存器到指令，都有一套独特的处理流程，浮点单元也称作x87FPU。浮点数的存储方式类型长度符号位指数位小数部分float321823double6411152float在内存中的存储方式|1位符号|8位指数|23位尾数我们来梳理一下float18.567在计算机中的存储是1100253495转成二进制后是01000001100101001000100100110111第一位为0代表是正数，1为负数10000011的十进制是131，由于指数部分有正负之分，所以以127为界限，即真实的指数部分是131-127=4小数部分是00101001000100100110111加1.得到1.00101001000100100110111扩大2^23得到100101001000100100110111转成十进制是9734455缩小2^23在乘以指数部分2^4也就等于是缩小2^199734455/2^19=18.566999435424805约等于18.567，所以浮点数是不精确的。关于指数的界限float类型2^8-1double类型2^11-1也就是2的指数位数次幂-1</li>
  <li>我们在使用系统API的时候，只能看到头文件。我们打开头文件，比如NSString.h找到方法stringWithFormat的定义。发现只是轻描淡写的一句+(instancetype)stringWithFormat:(NSString*)format,...NS_FORMAT_FUNCTION(1,2);但是当我们敲出来stringWithFormat，按住command鼠标点击这个方法的时候却发现有这么多注释SummaryReturnsastringcreatedbyusingagivenformatstringasatemplateintowhichtheremainingargumentvaluesaresubstituted.Declaration+(instancetype)stringWithFormat:(NSString*)format,...;DiscussionThismethodinvokesinitWithFormat:locale:arguments:withoutapplyinganylocalization.Thisisuseful,forexample,whenworkingwithfixed-formatrepresentationsofinformationthatiswrittenoutandreadbackinatalatertime.ImportantWhenworkingwithtextthat’spresentedtotheuser,usethelocalizedStringWithFormat:method,ortheinitWithFormat:locale:orinitWithFormat:locale:arguments:method,passingcurrentLocaleasthelocale.ParametersformatAformatstring.SeeFormattingStringObjectsforexamplesofhowtousethismethod,andStringFormatSpecifiersforalistofformatspecifiers.Thisvaluemustnotbenil.ImportantRaisesanNSInvalidArgumentExceptionifformatisnil....Acomma-separatedlistofargumentstosubstituteintoformat.ReturnsAstringcreatedbyusingformatasatemplateintowhichtheremainingargumentvaluesaresubstitutedwithoutanylocalization.这么多的注释来自哪里呢。起初我也困惑过，后来我想了想，可能来自于m文件，但是m文件我们看不到。前几天写了一个小工具，功能是把swagger上面的接口说明自动集成到项目里面，并且加上该有的接口说明，功能很简单，我写了三四个小时。为了看起来更整洁，我创建了2个文件。h文件保存简介的接口定义。列如staticNSString*constkApiGetSomeThing=@"/get/some/thing";//过获取一些东西同名m文件里保存复杂的注释，包括请求方式，参数说明例如/**@brief查询所有报警类型@code请求路径:/get/some/thing请求方法:get参数说明:param1string参数1param2string参数2@endcode*/externNSString*constkApiGetSomeThing;m文件主要起到一个快速查看注释的作用。当我们打出kApiGetSomeThing并查看注释的时候，就有快速提示。聪明的你不妨试试。今天遇到一个问题。发现快速提示竟然不好用了，纠结了几分钟，后来想了一下。可能是没有把接口.m文件加入到buildphrase的compileresource里面加入之后就正常了。时间太紧了，就写这些吧。最近压力太大了。</li>
  <li>Swift3:@escaping@escaping标明这个闭包是会“逃逸”,通俗点说就是这个闭包在函数执行完成之后才被调用.没有逃逸的闭包的作用域是不会超过函数本身的，所以说我们不需要担心在闭包内持有selfasas?as!as从派生类转换为基类，向上转类型(upcasting)classAnimal{}classDog:Animal{}letcat=Dog()letdog=catasAnimal消除二义性，数值类型转换letnum1=4asIntletnum2=5.09asCGFloatas!向下转型(Downcasting)时使用,由于是强制类型转换，如果转换失败会报runtime运行错误as?的使用场合as?和as!操作符的转换规则是一样的，只是as?在转换失败之后会返回nil对象</li>
  <li>Java注释@interface的用法java用@interfaceAnnotation{}定义一个注解@Annotation，一个注解是一个类@Override，@Deprecated，@SuppressWarnings为常见的3个注解。注解相当于一种标记，在程序中加上了注解就等于为程序加上了某种标记，以后javac编译器，开发工具和其他程序可以用反射来了解你的类以及各种元素上有没有任何标记，看你有什么标记，就去干相应的事情。注解@Override用在方法上，当我们想重写一个方法时，在方法上加@Override，当我们方法的名字出错时，编译器就会报错，如图：注解@Deprecated，用来表示某个类的属性或方法已经过时，不想别人再用时，在属性和方法上用@Deprecated修饰，如图：注解@SuppressWarnings用来压制程序中出来的警告，比如在没有用泛型或是方法已经过时的时候，如图：注解@Retention可以用来修饰注解，是注解的注解，称为元注解Retention注解有一个属性value，是RetentionPolicy类型的，EnumRetentionPolicy是一个枚举类型，这个枚举决定了Retention注解应该如何去保持，也可理解为Rentention搭配RententionPolicy使用。RetentionPolicy有3个值：CLASSRUNTIMESOURCE用@Retention(RetentionPolicy.CLASS)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，但不会被虚拟机读取在运行的时候；用@Retention(RetentionPolicy.SOURCE)修饰的注解,表示注解的信息会被编译器抛弃，不会留在class文件中，注解的信息只会留在源文件中；用@Retention(RetentionPolicy.RUNTIME)修饰的注解，表示注解的信息被保留在class文件(字节码文件)中当程序编译时，会被虚拟机保留在运行时，所以他们可以用反射的方式读取。RetentionPolicy.RUNTIME可以让你从JVM中读取Annotation注解的信息，以便在分析程序的时候使用.packagecom.self;importjava.lang.annotation.Retention;importjava.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public@interfaceMyTarget{}定义个一注解@MyTarget，用RetentionPolicy.RUNTIME修饰；packagecom.self;importjava.lang.reflect.Method;publicclassMyTargetTest{@MyTargetpublicvoiddoSomething(){System.out.println("helloworld");}publicstaticvoidmain(String[]args)throwsException{Methodmethod=MyTargetTest.class.getMethod("doSomething",null);if(method.isAnnotationPresent(MyTarget.class))//如果doSomething方法上存在注解@MyTarget，则为true{System.out.println(method.getAnnotation(MyTarget.class));}}}上面程序打印：@com.self.MyTarget()，如果RetentionPolicy值不为RUNTIME,则不打印@Retention(RetentionPolicy.SOURCE)public@interfaceOverride@Retention(RetentionPolicy.SOURCE)public@interfaceSuppressWarnings@Retention(RetentionPolicy.RUNTIME)public@interfaceDeprecated由上可以看出，只有注解@Deprecated在运行时可以被JVM读取到注解中可以定义属性，看例子：@Retention(RetentionPolicy.RUNTIME)public@interfaceMyAnnotation{Stringhello()default"gege";Stringworld();int[]array()default{2,4,5,6};EnumTest.TrafficLamplamp();TestAnnotationlannotation()default@TestAnnotation(value="ddd");Classstyle()defaultString.class;}上面程序中，定义一个注解@MyAnnotation，定义了6个属性，他们的名字为：hello,world,array,lamp,lannotation,style.属性hello类型为String,默认值为gege属性world类型为String,没有默认值属性array类型为数组,默认值为2，4，5，6属性lamp类型为一个枚举,没有默认值属性lannotation类型为注解,默认值为@TestAnnotation，注解里的属性是注解属性style类型为Class,默认值为String类型的Class类型看下面例子:定义了一个MyTest类，用注解@MyAnnotation修饰，注解@MyAnnotation定义的属性都赋了值@MyAnnotation(hello="beijing",world="shanghai",array={},lamp=TrafficLamp.RED,style=int.class)publicclassMyTest{@MyAnnotation(lannotation=@TestAnnotation(value="baby"),world="shanghai",array={1,2,3},lamp=TrafficLamp.YELLOW)@Deprecated@SuppressWarnings("")publicvoidoutput(){System.out.println("outputsomething!");}}接着通过反射读取注解的信息：publicclassMyReflection{publicstaticvoidmain(String[]args)throwsException{MyTestmyTest=newMyTest();Class&lt;MyTest&gt;c=MyTest.class;Methodmethod=c.getMethod("output",newClass[]{});//如果MyTest类名上有注解@MyAnnotation修饰，则为trueif(MyTest.class.isAnnotationPresent(MyAnnotation.class)){System.out.println("haveannotation");}if(method.isAnnotationPresent(MyAnnotation.class)){method.invoke(myTest,null);//调用output方法//获取方法上注解@MyAnnotation的信息MyAnnotationmyAnnotation=method.getAnnotation(MyAnnotation.class);Stringhello=myAnnotation.hello();Stringworld=myAnnotation.world();System.out.println(hello+","+world);//打印属性hello和world的值System.out.println(myAnnotation.array().length);//打印属性array数组的长度System.out.println(myAnnotation.lannotation().value());//打印属性lannotation的值System.out.println(myAnnotation.style());}//得到output方法上的所有注解，当然是被RetentionPolicy.RUNTIME修饰的Annotation[]annotations=method.getAnnotations();for(Annotationannotation:annotations){System.out.println(annotation.annotationType().getName());}}}上面程序打印：haveannotationoutputsomething!gege,shanghaibabyclassjava.lang.Stringcom.heima.annotation.MyAnnotationjava.lang.Deprecated如果注解中有一个属性名字叫value,则在应用时可以省略属性名字不写。可见，@Retention(RetentionPolicy.RUNTIME)注解中，RetentionPolicy.RUNTIME是注解属性值，属性名字是value,属性的返回类型是RetentionPolicy，如下：public@interfaceMyTarget{Stringvalue();}可以这样用：@MyTarget("aaa")publicvoiddoSomething(){System.out.println("helloworld");}注解@Target也是用来修饰注解的元注解，它有一个属性ElementType也是枚举类型，值为：ANNOTATION_TYPECONSTRUCTORFIELDLOCAL_VARIABLEMETHODPACKAGEPARAMETERTYPE如@Target(ElementType.METHOD)修饰的注解表示该注解只能用来修饰在方法上@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public@interfaceMyTarget{Stringvalue()default"hahaha";}如把@MyTarget修饰在类上，则程序报错，如：@MyTargetpublicclassMyTargetTest</li>
  <li>数据库操作delims为自定义的数据库名字。我使用的macOS版本MySQL8.0.17，需要在每条SQL语句后面加分号。database操作相关语句说明createdatabasedelims创建数据库delimsshowdatabases查询所有数据库dropdatabasedelims删除数据库delimsselectdatabase()查看当前使用的数据库usedelims使用数据库delimstable操作相关语句说明createtableperson创建person表showtables查询当前数据库的所有表renametablepersontoperson1person表重命名为person1droptableperson删除person表增删改查语句说明insertinto表名称values(值1,值2,….)给指定表插入数据deletefrom表名称列名称=值删除表中指定行deletefromtable_namedelete*fromtable_name删除所有的行select列表名from表从表中查询数据selectdistinct列表名from表返回结果集中去掉重复数据select*from表whereagebetween10and30区间条件过滤update表名称set列名称=新值where列名称=某值更新值select*frompersonlimit5返回5条数据</li>
  <li>iPhone屏幕分辨率，启动图分辨率iPhoneXSMax1242*2688iPhoneXR828*1792iPhoneX1125*2436Retina5.5“1242*2208Retina4.7”750*1334Retina4“640*1136Retina3.5”640*960iPad1536*2048</li>
  <li>总结一下开发过程遇到的特殊情况，需要注意的点iOS9-iOS11的系统使用Xib布局cell，设置UITableViewAutomaticDimension自动计算高度时会提示如下的错误。解决办法，可以给其中一个高度约束设置priority为小于1000。2019-08-2213:29:16.973702+0800BoChuang[58487:1511846][LayoutConstraints]Unabletosimultaneouslysatisfyconstraints.Probablyatleastoneoftheconstraintsinthefollowinglistisoneyoudon'twant.Trythis:(1)lookateachconstraintandtrytofigureoutwhichyoudon'texpect;(2)findthecodethataddedtheunwantedconstraintorconstraintsandfixit.("&lt;NSLayoutConstraint:0x600000092890UIImageView:0x7fe453f7dfe0.height==48&gt;","&lt;NSLayoutConstraint:0x600000092520UIView:0x7fe453f37590.height==10&gt;","&lt;NSLayoutConstraint:0x60000008eb50UIImageView:0x7fe453f7dfe0.top==UITableViewCellContentView:0x7fe453f55220.top+10&gt;","&lt;NSLayoutConstraint:0x600000094230UIView:0x7fe453f37590.top==UIImageView:0x7fe453f7dfe0.bottom+10.5&gt;","&lt;NSLayoutConstraint:0x600000094280UITableViewCellContentView:0x7fe453f55220.bottom==UIView:0x7fe453f37590.bottom&gt;","&lt;NSLayoutConstraint:0x600000094aa0UITableViewCellContentView:0x7fe453f55220.height==78.6667&gt;")Willattempttorecoverbybreakingconstraint&lt;NSLayoutConstraint:0x600000092890UIImageView:0x7fe453f7dfe0.height==48&gt;MakeasymbolicbreakpointatUIViewAlertForUnsatisfiableConstraintstocatchthisinthedebugger.ThemethodsintheUIConstraintBasedLayoutDebuggingcategoryonUIViewlistedin&lt;UIKit/UIView.h&gt;mayalsobehelpful.</li>
  <li>说真的，很久没有开发项目了，得有半年了，最近公司开发了一个项目，项目比较简单，要求独立开发8天完成。完成的还算比较顺利，但是中间还是遇到了一些坑坑。一些坑都是之前遇到过的，结果又百度了一遍，不得不承认最近状态不好，记忆力明显下降。所以在此记录一下，加强一下记忆。公司开发的项目就是一个简单的问答系统。问题：使用hidesBottomBarWhenPushed，push后又pop结果状态栏和导航栏都变色了。从viewdebug上面看好像是里面有一层黑色。解决办法:原来是因为没有给UIWindow设置一个背景色，添加背景色为白色后问题解决。问题：设置UITableViewAutomaticDimension后在iOS9和iOS10的系统上面cell缩成了一团。解决办法：iOS系统版本号≤10的系统，必须设置estimatedRowHeight才可以，可以直接设置给tableview也可以在代理实现返回estimatedRowHeight的方法。问题：用计时器更新button上的秒数时闪烁解决办法：把button的类型改成custom，默认是system直接写注意事项吧。下面是注意事项safeArea是iOS11的新特性，用xib开发界面时可以直接以safeArea为参照进行布局。在iOS11和iOS12的系统上可以正常显示。由于safeArea中不包含状态栏，如果view的top和safeArea的top一样，那么在iOS11和12的系统上会从状态栏下面开始。在iOS10及以下版本上，top依然会从屏幕顶部开始。这样一来iOS10的系统就会向上偏移20个点。可以在代码中判断版本号手动修改约束值。写九宫格显示图片的时候，用UICollection的子类实现，给UICollection设置图片的时候，会根据图片数量修改自身高度约束。之前我为了减少耦合，让UICollection自己去遍历自己的高度约束，这样性能太差了，而且引起了cell高度显示不准确。后来干脆直接从xib中拉一根线赋值给UICollection，不要让UICollection和蒙头苍翼一样去到处找了。这样性能提高了，cell高度也正常了。关于controller跳转时候navigationBarHidden的问题####情景如下A页面是根页面，有导航栏B页面没有导航栏想由Apush到B侧滑手势失效。总结：使用[self.navigationControllersetNavigationBarHidden:YESanimated:NO];会隐藏导航，并且手势消失使用self.navigationController.navigationBar.hidden=YES;隐藏导航栏手势可用，但是会导致push的过度效果不好看。针对1的情况，可以在B页面这样设置来启用手势。需要让self实现UIGestureRecognizerDelegate，可以不用实现具体方法。self.navigationController.interactivePopGestureRecognizer.delegate=self;最大的坑以前做的项目上传图片要么是用的阿里云要么就是用post只传一张图片给后台，就是直接把图片的data数据赋值给HTTPbody。非常简单。这次要求上传图片的时候还带有一个业务参数，这可把我难倒了，我记得之前我就对这种方式有抵触，但是太懒了，一些生活琐事也让我无心专心学习。但是这次遇上了不得不解决。最后通过查资料得知HTTPbody的数据有格式，通过boundary进行参数分割。最后我用AFNetworking封装好的下面这段代码实现了需求。AFHTTPSessionManager*manage=[AFHTTPSessionManagermanager];[manage.requestSerializersetValue:@"application/multipart/form-data"forHTTPHeaderField:@"Content-Type"];manage.requestSerializer=[AFHTTPRequestSerializerserializer];manage.responseSerializer=[AFHTTPResponseSerializerserializer];manage.responseSerializer.acceptableContentTypes=[NSSetsetWithObjects:@"application/json",@"text/html",@"text/json",@"text/javascript",@"text/plain",nil];[managePOST:self.URL.absoluteStringparameters:nilconstructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;_NonnullformData){//业务参数imageType的值是2[formDataappendPartWithFormData:[@"2"dataUsingEncoding:NSUTF8StringEncoding]name:@"imageType"];//把图片通过参数imageFile传给后台[formDataappendPartWithFileData:self.formDataname:@"imageFile"fileName:@"a.jpg"mimeType:@"image/jpeg"];}progress:^(NSProgress*_NonnulluploadProgress){}success:^(NSURLSessionDataTask*_Nonnulltask,id_NullableresponseObject){BCRequestResponseModel*model=[BCRequestResponseModelmodelWithJSON:responseObject];completion(model,nil);NSLog(@"%@",responseObject);}failure:^(NSURLSessionDataTask*_Nullabletask,NSError*_Nonnullerror){completion(nil,error);}];</li>
  <li>苹果源码里的各种宏定义OBJC_ISA_AVAILABILITY以前不知道runtime源码的时候每次看runtime.h文件时看到这个宏定义就头大，现在可以解开他神秘的面纱了/*OBJC_ISA_AVAILABILITY:`isa`willbedeprecatedorunavailable*inthefuture*/#if!defined(OBJC_ISA_AVAILABILITY)#if__OBJC2__#defineOBJC_ISA_AVAILABILITY__attribute__((deprecated))#else#defineOBJC_ISA_AVAILABILITY/*stillavailable*/#endif#endif__OBJC2__这个宏也是经常看到的一个宏，我们来看看它是怎么定义的//Define__OBJC2__forthebenefitofourasmfiles.#ifndef__OBJC2__#ifTARGET_OS_OSX&amp;&amp;!TARGET_OS_IOSMAC&amp;&amp;__i386__//oldABI#else#define__OBJC2__1#endif#endif这里有一个名词ABI（ApplicationBinaryInterface）:应用程序二进制接口描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低接口。我没有找到TARGET_OS_IOSMAC是怎么定义的，我暂且理解为运行iOS系统的Mac吧，如果有大神知道，望不吝赐教。OBJC2_UNAVAILABLE/*OBJC2_UNAVAILABLE:unavailableinobjc2.0,deprecatedinLeopard*/#if!defined(OBJC2_UNAVAILABLE)#if__OBJC2__#defineOBJC2_UNAVAILABLEUNAVAILABLE_ATTRIBUTE#else/*plainCcodealsofallshere,butthisiscloseenough*/#defineOBJC2_UNAVAILABLE\__OSX_DEPRECATED(10.5,10.5,"notavailablein__OBJC2__")\__IOS_DEPRECATED(2.0,2.0,"notavailablein__OBJC2__")\__TVOS_UNAVAILABLE__WATCHOS_UNAVAILABLE__BRIDGEOS_UNAVAILABLE#endif#endifUNAVAILABLE_ATTRIBUTE/**onlycertaincompilerssupport__attribute__((unavailable))*/#ifdefined(__GNUC__)&amp;&amp;((__GNUC__&gt;=4)||((__GNUC__==3)&amp;&amp;(__GNUC_MINOR__&gt;=1)))#defineUNAVAILABLE_ATTRIBUTE__attribute__((unavailable))#else#defineUNAVAILABLE_ATTRIBUTE#endif__attribute__((unavailable))告诉编译器该方法不可用.OBJC_OLD_DISPATCH_PROTOTYPES/*OBJC_OLD_DISPATCH_PROTOTYPES==0enforcestherulethatthedispatch*functionsmustbecasttoanappropriatefunctionpointertype.*/#if!defined(OBJC_OLD_DISPATCH_PROTOTYPES)#if__swift__//ExistingSwiftcodeexpectsIMPtobeComparable.//VariadicIMPiscomparableviaOpaquePointer;non-variadicIMPisn't.#defineOBJC_OLD_DISPATCH_PROTOTYPES1#else#defineOBJC_OLD_DISPATCH_PROTOTYPES1#endif#endifobjc_old_dispatch_prototype==0强制执行分派规则函数必须转换为适当的函数指针类型。</li>
  <li>开门见山命令查看当前目录下所有文件夹的大小-d指深度，后面加一个数值df-d1-h</li>
  <li>平时在阅读一些优秀第三方库代码的时候是不是会遇到__attribute__((always_inline))这样的关键字而懵逼。看了下面的文章相信你会变得更自信。aligned用于内存字节对齐。structstu{charsex;intlength;;}__attribute__((aligned(1)));//用于内存对齐,只能传入2的N次方，传1，2，4以4字节对齐。传8是8字节对齐。always_inline声明为内联函数，声明后函数在调用的时候直接复制代码。__attribute__((always_inline))voidinlineFunction(){}objc_subclassing_restricted声明类不允许被继承，如果被继承会编译报错__attribute__((objc_subclassing_restricted))@interfaceFinalObject:NSObject@endobjc_requires_super声明方法重载时需要调用父类的方法,Foundation框架已经定义了这个宏。NS_REQUIRES_SUPER-(void)func__attribute__((objc_requires_super));//Foundation框架定义了这宏#ifndefNS_REQUIRES_SUPER#if__has_attribute(objc_requires_super)#defineNS_REQUIRES_SUPER__attribute__((objc_requires_super))#else#defineNS_REQUIRES_SUPER#endif#endifobjc_boxable这个属性是可以将struct或者unions转换成NSValuestruct__attribute__((objc_boxable))_some_struct{inti;};union__attribute__((objc_boxable))some_union{inti;floatf;};typedefstruct__attribute__((objc_boxable))_some_structsome_struct;intmain(){some_structss;NSValue*boxed=@(ss);//如果去掉objc_boxable这里就会报错}constructor/destructor在执行文件load和unload时候被调用。__attribute__((constructor))staticvoidbeforeMain(void){NSLog(@"beforeMain");}__attribute__((destructor))staticvoidafterMain(){NSLog(@"afterMain");}enable_if这个属性只能用在C函数上，可以用来实现参数的静态检查：staticvoidprintValidAge(intage)__attribute__((enable_if(age&gt;0&amp;&amp;age&lt;120,"你丫火星人？"))){printf("%d",age);}voidfoo(charc){printValidAge(99);printValidAge(199);}intmain(intargc,constchar*argv[]){return0;}cleanup声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，如下当string的作用域结束会调用func函数。__strongNSString*string__attribute__((cleanup(func)))=@"字符串";overloadable让C语言支持参数重载__attribute__((overloadable))voidlogAnything(idobj){NSLog(@"%@",obj);}__attribute__((overloadable))voidlogAnything(intnumber){NSLog(@"%@",@(number));}__attribute__((overloadable))voidlogAnything(CGRectrect){NSLog(@"%@",@(rect));}objc_runtime_name用于@interface或@protocol，将类或协议的名字在编译时指定成另一个，如下在编译时候类名会被指定为MyLocalName__attribute__((objc_runtime_name("MyLocalName")))@interfaceMessage:NSObject@end_Noreturn_Noreturn关键词出现于函数声明中，指定函数不会由于执行到return语句或抵达函数体结尾而返回,（可通过执行longjmp返回）调用函数没有返回值，所以程序就停在函数里面了_Noreturnvoidstop_now(inti)//或_Noreturnvoidstop_now(inti){if(i&gt;0)exit(i);}intmain(void){puts("Preparingtostop...");stop_now(2);puts("Thiscodeisneverexecuted.");}availability该availability属性可以放在声明上，以描述相对于操作系统版本的声明的生命周期。考虑假设函数的函数声明f可用性属性表示f在macOS10.4中引入，在macOS10.6中已弃用，在macOS10.7中已废弃。voidf(void)__attribute__((availability(macos,introduced=10.4,deprecated=10.6,obsoleted=10.7)));deprecated(gnu::deprecated)废弃的api。voidf(void)__attribute__((deprecated("message","replacement")));</li>
  <li>出现问题原因：commit相互依赖。具体讲就是：gerrit上已经存在commitA（commitA还未merge入库），然后你在commitA的代码基础上进行了修改（划重点，基于A修改！），并做了新的commitB，commitB已经包含了commitA的修改，于是在gerrit上abondoncommitA，只留下commitB在gerrit上，这样一来，commitBreview通过后做merge时你就会得到标题中的错误。#解决方法：从远程分支上重新创建一个新的工作分支：gitfetchoriginmaster(远程分支):new_work(新分支)切换到新的工作分支：gitcheckoutnew_work将commitB移到新分支上（gerrit页面右上角download中直接复制cherry-pich命令）：gitfetchssh://xxxxxx&amp;&amp;gitcherry-pichxxx正常解决冲突流程，不做复述正常提交代码：gitpushoriginHEAD:refs/for/mater(需要提交到的分支)刷新gerrit，重新做codereview。原文地址:https://blog.csdn.net/qq_35168368/article/details/83109016</li>
  <li>#CAGradientLayer我们可以通过简单的代码实现投影shadowView.layer.shadowOpacity=1;shadowView.layer.shadowOffset=CGSizeMake(0,3);//投影的方向，该值为向下3个点shadowView.layer.shadowRadius=3;//投影半径，模糊渐变的宽度shadowView.layer.shadowColor=[UIColorblueColor].CGColor//投影颜色通过上述代码实现的投影为四周投影，有时候我们可能想实现只为View的一个边添加投影，可以这样做。通过CAGradientLayer。CAGradientLayer可以设置多个颜色，多个颜色渐变的点，在点和点之间进行均匀的渐变。CAGradientLayer*gradientLayer=[CAGradientLayerlayer];gradientLayer.colors=@[(__bridgeid)[UIColorcolorWithRed:value1green:value1blue:value1alpha:1].CGColor,(__bridgeid)[UIColorcolorWithRed:value2green:value2blue:value2alpha:1].CGColor,];;//渐变色gradientLayer.startPoint=CGPointMake(1.0,0);gradientLayer.endPoint=CGPointMake(0,0);gradientLayer.frame=CGRectMake(9,0,11,39);通过这种方式设置后CAGradientLayer的颜色会进行均匀渐变</li>
  <li>前言每次阅读runtime的头文件时看到__OBJC2__时就很疑惑，这到底是个什么？从字面意思来看像是Objetive-C语言的2.0版本。我们都听说过swift语言的版本号，但是却很少听说Objetive-C的版本号。那么问题来了Objetive-C语言一共有几种版本？分别运行在什么系统上？百度__OBJC2__找不到任何这方面的答案，每当此时我就很苦恼，我觉得我应该找到这个答案。终于在stackoverflow中找到了我所需要的答案，于是豁然开朗帖子原文Q：HowdoiknowwhatversionofObjClanguageamiusing?Thisiskindofasillyquestion,butreally,howcanitellwhetheriamusingObjCversion2orsomethingelse?Icanalwaysassume“thelatest”,buti’dratherknow:)Isthereacommandlinecheckicanrun?PleaseadviseA:Ifyouarerunning10.5orlater,oranyversionofiOS,yourcomputerisrunningObjective-C2.Ifyouarewritingcodewhichyouwanttoworkonsystemsbeforethis,youcancheckforthe__OBJC2__macro,whichwillbedefinedonlyforObjective-C2andlatersystems.#ifdef__OBJC2__//useobjective-c2#elifdefined(__OBJC__)//useobjective-c1#else//noobjective-c#endif原文地址https://stackoverflow.com/questions/7115325/how-do-i-know-what-version-of-objc-language-am-i-using/7115351#7115351))总结Objective-C有两个版本1.0和2.0。__OBJC2__为真代表当前使用的是Objective-C2.0macOS10.5及以后的版本使用的是Objective-C2.0，版本号小于10.5的系统是Objective-C1.0任何iOS系统都是Objective-C2.0可以推断出在iOS系统中__OBJC2__永远为YES在此十分感谢stackoverflow，感谢ughoavgfhw，虽然这不是一个什么高深的问题，但是它解开了一个长期存在我心中的疑惑。</li>
  <li>2018年08月22日git项目文件忽略规则在仓库目录下新建一个.gitignore文件，里面填写相应的忽略规则，即可忽略文件，一行一个规则，规则如下：规则语法忽略.o和.a文件*.[oa]忽略.b和.B文件，my.b除外*.[bB]!my.b忽略Pods文件和Pods目录Pods只忽略Pods目录，不忽略Pods文件Pods/只忽略Pods文件，不忽略Pods目录Pods!Pods/只忽略当前目录下的Pod文件和目录子目录的Pod不在忽略范围内/Pod命令行下git和svn实现换行可以用单引号’把提交的注释括起来。像这样$gitcommit-m'我要换行了哦&gt;你看我换行了吧，哈哈哈'编辑已经提交的git注释用命令gitcommit--amend可以修改最后一次的提交，执行这个命令后打印出日志，直接编辑然后保存。svn已经add的文件如何变成未add的状态$svnrevert[PATH]--depthinfinitysvn批量删除文件$svnst|grep!|awk'{print$2"@"}'|xargssvndelsvnlog指定时间段和用户$svnlog-r{2018-8-1}:{2018-8-31}--searchdelims//查看用户delims这个时间段的提交日志$svnlog-r5748:5767//查看两个版本号之间的提交日志IntrinsicContentSizeContentCompressionResistance–&gt;如果内容的抗压缩阻力的优先级越高，那么视图越不容易被压缩；ContentHugging–&gt;如果内容的抗拉伸阻力的优先级越高，那么视图越不容易被拉伸；</li>
  <li>前言用Xcode创建一个iOS项目时会提示是否勾选UnitTests和UITests，勾选后创建项目自动生成如下两个target:(项目名)+Tests(项目名)+UITests我填写的项目名是Test_3rd_party_Library,展开目录Test_3rd_party_Library可以看到只有一个Test_3rd_party_LibraryTests.m文件和一个info.plist文件。我们看到.m是一个类，它没有.h文件，它继承自XCTestCase，继承关系：Test_3rd_party_LibraryTests-&gt;XCTestCase-&gt;XCTest-&gt;NSObjectXCTest还有一个子类XCTestSuite,XCTestSuite是测试用例的集合XCTestCase是定义测试用例、测试方法和性能测试的主要类。XCTestCase的方法和属性英文注释是自动创建的，中文的是我加的，我们来看一下#import&lt;XCTest/XCTest.h&gt;@interfaceTest_3rd_party_LibraryTests:XCTestCase@end@implementationTest_3rd_party_LibraryTests-(void)setUp{[supersetUp];//Putsetupcodehere.Thismethodiscalledbeforetheinvocationofeachtestmethodintheclass.//说白了，就是每次执行一个test开头的方法前都会先用调这个方法}-(void)tearDown{//Putteardowncodehere.Thismethodiscalledaftertheinvocationofeachtestmethodintheclass.//说白了，就是每次执行完一个test开头的方法后都会调用这个方法[supertearDown];}-(void)testExample{//Thisisanexampleofafunctionaltestcase.//UseXCTAssertandrelatedfunctionstoverifyyourtestsproducethecorrectresults./*测试用例方法，这个方法需要满足下面几个条件1.开头必须是test2.没有参数3.没有返回值每个test方法前面都有一个菱形，未运行之前是空心的，当我们点击菱形运行之后，如果成功就变成一个对勾，如果失败就变成一个叉号。如果你写了test方法并没有自动生成菱形，那就build一下*/}-(void)testPerformanceExample{//Thisisanexampleofaperformancetestcase.[selfmeasureBlock:^{//Putthecodeyouwanttomeasurethetimeofhere.}];/*这个方法用来测试代码的性能，将需要测试的代码放到block里面，运行方法，执行结束后会打印运行用时。*/}@end以上几个方法是系统自动添加到子类文件中的。还有几个方法也可以了解一下//名字随意，开头必须是test-(void)testPerformanceExample2{//如果需要更细化的定制代码的性能测试，可以用这个方法//measureMetrics是一个字符串数组，包含了可由XCTest度量的性能指标。//automaticallyStartMeasuring指定是否自动执行startMeasuring方法。如果为NO，则需要手动在你需要进行性能测试开始的位置加入[selfstartMeasuring]，如果为YES，则系统自动执行，我猜测应该是block开始的时候执行，此时如果在手动加入[selfstartMeasuring]就会报错。[selfmeasureMetrics:[selfclass].defaultPerformanceMetricsautomaticallyStartMeasuring:NOforBlock:^{//Dosetupworkthatneedstobedoneforeveryiterationbutyoudon'twanttomeasurebeforethecallto-startMeasuringSetupSomething();[selfstartMeasuring];//Dothatthingyouwanttomeasure.MyFunction();//性能测试结束的位置插入，此方法最多只能执行一次，如果不添加，block结束后自动执行[selfstopMeasuring];//Doteardownworkthatneedstobedoneforeveryiterationbutyoudon'twanttomeasureafterthecallto-stopMeasuringTeardownSomething();}];}//在需要测试代码性能开始的地方执行这个方法-(void)startMeasuring{[superstartMeasuring];}//测试结束的时候执行这个方法，-(void)stopMeasuring{[superstopMeasuring];}我测试了一下不管运行哪个measureMetrics方法，startMeasuring和stopMeasuring都会成对调用10次，不知道这个10次是怎么来的，如果你知道的话欢迎发邮件给我。</li>
  <li>前言在UML类图中，常见的有以下几种关系:泛化（Generalization）,实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)泛化（Generalization）【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。【箭头指向】：带三角箭头的实线，箭头指向父类实现（Realization）【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.【箭头指向】：带三角箭头的虚线，箭头指向接口关联（Association)【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。【代码体现】：成员变量【箭头及指向】：带普通箭头的实心线，指向被拥有者聚合（Aggregation）【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【代码体现】：成员变量【箭头及指向】：带空心菱形的实心线，菱形指向整体组合(Composition)【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。【代码体现】：成员变量【箭头及指向】：带实心菱形的实线，菱形指向整体依赖(Dependency)【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.【代码表现】：局部变量、方法的参数或者对静态方法的调用【箭头及指向】：带箭头的虚线，指向被使用者</li>
  <li>前言开发这几年来，基本都是用的svn客户端管理来管理代码,用过Versions和CornerStone，很少用命令行，对svn的命令掌握的也不全。我觉得要想在开发这条路上走的更远，熟练的用命令行来管理代码是最基本的技能。用svn命令行管理代码并不复杂，很容易学习，熟练之后会觉得比图形化工具还方便，因为只用键盘就可以操作。最主要是还可以提高逼格。我觉得十分有必要抽一点时间系统的学习一下svn的常用命令。创建一个本地SVN仓库为了方便演示svn命令，又不想用自己公司的服务器，可以先搭建一个本地svn服务器。打开终端输入命令：delimss-MacBook-Pro:~delims$svnadmincreate~/svnserver/delimss-MacBook-Pro:~delims$svnadmincreate[PATH]是在本地创建一个仓库，此时控制台没有任何输出，我们看看这个目标下生成的文件delimss-MacBook-Pro:~delims$cd~/svnserver/delimss-MacBook-Pro:svnserverdelims$lsREADME.txtdbhooksconfformatlocks可以看到生成了一堆文件和文件夹，conf文件夹里包含了仓库的配置信息看下里面有什么delimss-MacBook-Pro:svnserverdelims$cdconf/delimss-MacBook-Pro:confdelims$lsauthzhooks-env.tmplpasswdsvnserve.conf可以看到conf文件夹里包含了4个文件文件说明svnserve.conf守护进程配置文件authz保存了用户名和权限passwd保存了用户名的密码hooks-env.tmpl钩子脚本环境配置文件这几个配置文件，有用的代码都是被注释掉的，我们需要手动修改一下，主要是删除注释符号#，其次也会适当做些修改，修改如下：svnserve.conf修改前修改后说明[general]#anon-access=read#auth-access=write#password-db=passwd#authz-db=authz[general]anon-access=noneauth-access=writepassword-db=passwdauthz-db=authzanon-access代表匿名访问权限赋值给none表示不允许匿名访问注意:#后面有一个空格也要删除authz修改前修改后说明[groups]#harry_and_sally=harry,sally#[/foo/bar]#harry=rw#*=r[groups]harry_and_sally=harry,sally[/]&amp;harry_and_sally=rw*=r修改这三行，即创建两个用户并组成一个group，并给予此group所有成员根目录的读写权限passwd修改前修改后说明[users]#harry=harryssecret#sally=sallyssecret[users]harry=123sally=123设置用户密码，只是用来演示，我们就设置一个简单的吧启动本地svn服务器配置好以后，我们就启动服务器，键入命令：delimss-MacBook-Pro:confdelims$svnserve-d-r~/svnserver/delimss-MacBook-Pro:confdelims$ps-e|grepsvn974??0:00.00/Applications/Xcode.app/Contents/Developer/usr/bin/svnserve-d-r/Users/delims/svnserver/977ttys0000:00.00grepsvn此时可以看到成功开启了svnserve进程，还可以发现svnserve工具是包含在Xcode中的，不得不感叹，Xcode真是一个百宝囊。我们随便找个目录把我们本地svn服务器上的仓库拉下来delimss-MacBook-Pro:tempdelims$svncosvn://localhostAuthenticationrealm:&lt;svn://localhost:3690&gt;7a441335-b969-42c4-aa80-56391f894982Passwordfor'delims':*****//输入macOS用户密码Authenticationrealm:&lt;svn://localhost:3690&gt;7a441335-b969-42c4-aa80-56391f894982Username:harry//刚才配置的用户名harryPasswordfor'harry':***//输入我们配置的简单密码123Checkedoutrevision0.//成功检出，版本号为0可以看到成功检出了我们本地服务器的仓库并放在了本地。。。svn命令行操作我们先来添加一个文件并提交到服务器delimss-MacBook-Pro:tempdelims$echo1&gt;1.txt//添加一个文件delimss-MacBook-Pro:tempdelims$ls1.txt//文件添加了delimss-MacBook-Pro:tempdelims$svnst?1.txt//可以看到此文件的状态是？，也就是还没有加入到版本控制delimss-MacBook-Pro:tempdelims$svnadd1.txt//加入到版本控制A1.txt//状态变为A，表示已经加入到了版本控制//提交到服务器，并添加注释delimss-MacBook-Pro:tempdelims$svnci1.txt-m"提交第一个文件"Adding1.txtTransmittingfiledata.doneCommittingtransaction...Committedrevision1.//已成功上传到服务器，版本号+1为了更好的演示，我将AFNetworking的源码放到根目录delimss-MacBook-Pro:tempdelims$ls1.txtAFNetworkingdelimss-MacBook-Pro:tempdelims$svnst?AFNetworking//可以看到AFNetworking还没有加入版本控制delimss-MacBook-Pro:tempdelims$svnaddAFNetworking/\\添加上这句命令执行完会显示有大量的被添加记录，下面提交到服务器delimss-MacBook-Pro:tempdelims$svnciAFNetworking-m"添加AFNetworking"这句命令执行完后，最后面会显示，说明一已经成功上传到服务器，版本号是2Transmittingfiledata..................................................................................................................................................................................................................................doneCommittingtransaction...Committedrevision2.delimss-MacBook-Pro:tempdelims$svnst//查看状态，没有任何输出，表示当前没有文件变动delimss-MacBook-Pro:tempdelims$svninfo//查看当前svn信息，发现版本号依然是0Path:.WorkingCopyRootPath:/Users/delims/tempURL:svn://localhostRelativeURL:^/RepositoryRoot:svn://localhostRepositoryUUID:7a441335-b969-42c4-aa80-56391f894982Revision:0NodeKind:directorySchedule:normalLastChangedRev:0LastChangedDate:2018-08-1709:59:13+0800(Fri,17Aug2018)更新一下代码delimss-MacBook-Pro:tempdelims$svnupdate//更新一下svnUpdating'.':Atrevision2.delimss-MacBook-Pro:tempdelims$svninfoPath:.WorkingCopyRootPath:/Users/delims/tempURL:svn://localhostRelativeURL:^/RepositoryRoot:svn://localhostRepositoryUUID:7a441335-b969-42c4-aa80-56391f894982Revision:2NodeKind:directorySchedule:normalLastChangedAuthor:harryLastChangedRev:2LastChangedDate:2018-08-1712:55:56+0800(Fri,17Aug2018)查看一下svn提交记录delimss-MacBook-Pro:tempdelims$svnlog------------------------------------------------------------------------r2|harry|2018-08-1712:55:56+0800(Fri,17Aug2018)|1line添加AFNetworking------------------------------------------------------------------------r1|harry|2018-08-1711:44:12+0800(Fri,17Aug2018)|1line提交第一个文件------------------------------------------------------------------------PS:这个命令是查看当前仓库所有文件的所有提交记录，如果只是查看某个文件的记录就这样delimss-MacBook-Pro:tempdelims$svnlog1.txt------------------------------------------------------------------------r1|harry|2018-08-1711:44:12+0800(Fri,17Aug2018)|1line提交第一个文件------------------------------------------------------------------------如果只查看最近的几条记录就这样delimss-MacBook-Pro:tempdelims$svnlog-l1//查看最近的1条记录------------------------------------------------------------------------r2|harry|2018-08-1712:55:56+0800(Fri,17Aug2018)|1line添加AFNetworking------------------------------------------------------------------------当前版本是2，如果我要回到版本1.就这样delimss-MacBook-Pro:tempdelims$svnupdate-r1//指定版本号Updating'.':DAFNetworkingUpdatedtorevision1.delimss-MacBook-Pro:tempdelims$ls1.txt//已经回到版本1浏览服务器上的文件可以这样操作delimss-MacBook-Pro:tempdelims$svnlistsvn://localhost1.txtAFNetworking/delimss-MacBook-Pro:tempdelims$svnlistsvn://localhost/AFNetworking.cocoadocs.yml.git/.gitignore.travis.ymlAFNetworking/AFNetworking.podspecAFNetworking.xcodeproj/AFNetworking.xcworkspace/CHANGELOG.mdCONTRIBUTING.mdExample/Framework/LICENSEREADME.mdTests/UIKit+AFNetworking/fastlane/delimss-MacBook-Pro:tempdelims$创建一个新分支delimss-MacBook-Pro:tempdelims$svncopysvn://localhost/AFNetworkingsvn://localhost/AFNetworking2-m"创建一个新分支"Committingtransaction...Committedrevision3.再来看下服务器上的目录delimss-MacBook-Pro:tempdelims$svnlistsvn://localhost1.txtAFNetworking/AFNetworking2/可以看到服务器上的目录已经被更改了更新本地，delimss-MacBook-Pro:tempdelims$svnupdate这里会输出大量日志delimss-MacBook-Pro:tempdelims$ls1.txtAFNetworkingAFNetworking2可以看到本地文件和服务器同步了修改文件delimss-MacBook-Pro:tempdelims$svnstMAFNetworking/README.mddelimss-MacBook-Pro:tempdelims$svnciAFNetworking/README.md-m"修改一个文件"SendingAFNetworking/README.mdTransmittingfiledata.doneCommittingtransaction...Committedrevision4.先介绍这些吧键入svnhelp查看svn所有命令,打印如下:add&lt;br&gt;auth&lt;br&gt;blame(praise,annotate,ann)&lt;br&gt;cat&lt;br&gt;changelist(cl)&lt;br&gt;checkout(co)&lt;br&gt;cleanup&lt;br&gt;commit(ci)&lt;br&gt;copy(cp)&lt;br&gt;delete(del,remove,rm)&lt;br&gt;diff(di)&lt;br&gt;export&lt;br&gt;help(?,h)&lt;br&gt;import&lt;br&gt;info&lt;br&gt;list(ls)&lt;br&gt;lock&lt;br&gt;log&lt;br&gt;merge&lt;br&gt;mergeinfo&lt;br&gt;mkdir&lt;br&gt;move(mv,rename,ren)&lt;br&gt;patch&lt;br&gt;propdel(pdel,pd)&lt;br&gt;propedit(pedit,pe)&lt;br&gt;propget(pget,pg)&lt;br&gt;proplist(plist,pl)&lt;br&gt;propset(pset,ps)&lt;br&gt;relocate&lt;br&gt;resolve&lt;br&gt;resolved&lt;br&gt;revert&lt;br&gt;status(stat,st)&lt;br&gt;switch(sw)&lt;br&gt;unlock&lt;br&gt;update(up)&lt;br&gt;upgrade&lt;br&gt;</li>
  <li>背景某互联网公司产品经理提了个需求，要求app做到可以根据用户手机壳颜色来改变app主题颜色，最后产品经理和程序员打了起来。最近这件事刷了屏，不知道这件事是不是网友故意调侃。自古以来程序员和产品经理似乎都是一对冤家，哈哈，扯远了。想想产品经理提的这个需求也挺奇葩的。这个根本没法实现嘛，气愤中。。冷静下来，思考一下，这个需求到底能不能实现呢？我觉得可以考虑从下面这个方案入手。方案启动前置摄像头，根据拍摄到的用户眼睛中手机壳的倒影来检测手机壳的颜色。可行性要想检测用户眼睛中手机的倒影，那需要先分析一下前置摄像头的视力是多少。我们都知道正常人视力是1.0，对应的视角是1角分，当然也有好眼1.5或2.0，对应视角是0.7角分和0.5角分。我用iPhone6s距离5米通过后置摄像头拍摄视力表，大概可以勉强拍清1.2，1.2已经开始模糊，1.5已经变成了小黑点。iPhone6s的后置摄像头是1200万像素，而前置摄像头低于这个像素。我没有使用过手机的前置摄像头拍摄过视力表，但是可以通过像素数来大体推算一下iPhone6s前置摄像头是500万像素，对应视力500/1200*1.2=0.5iPhoneX前摄摄像头是700万像素，对应视力700/1200*1.2=0.7凸面镜凸面镜成像，属于光学规律。平行光线投射到凸面镜上，反射的光线将成为散开光线，如果顺着反射光线的相反方向延伸到凸面镜镜面的后面，可会聚并相交于一点，这一点就是凸面镜的主焦点（F）。角膜可以看做是一个凸面镜，角膜的屈光度是43D(数据来自于《眼科学》)，那么角膜的焦距是1÷43≈0.0233米，即2.33厘米，如果一束平行光通过角膜反射产生倒影，那么倒影的虚像就在角膜后方的2.33厘米处。但是我们看手机，手机漫反射发出的光不是平行光，而是散射光，散射光通过角膜反射产生的倒影距离角膜光心比平行光要远。远多少呢。我们来计算一下。假设我们看手机的距离是30厘米，这30厘米也是焦距，产生的屈光度是1÷0.3≈3.3D这个屈光度会抵消掉角膜的屈光度，那么倒影的焦距是1÷(43-3.3)≈0.0252米，即2.52厘米倒影的大小是多少呢。手机壳基本都是套在手机上，正面看只能看到边框，假设手机壳的边框宽度是0.5厘米，根据相似三角形可以计算出，倒影中边框的宽度是2.52÷(2.52+30)*0.5≈0.0775厘米你是不是被绕晕了？没关系，你只需要知道0.0775厘米就是距离眼睛30厘米的手机壳边框在角膜中倒影的宽度就可以了。手机前置摄像头要想辨认角膜中的手机壳，那么需要的视角是多少呢？我们可以大体看做这是一个由0.0775厘米和30+2.52厘米作为两条直角边形成的直角三角形，这个最小的锐角就是视角，通过反三角函数计算得出视角是arcsin(0.0775÷32.52)≈0.1365445°转成角分就是8.193′这个视角对应的视力是多少度呢推算一下视力1.0的视角是1′视力0.1的视角是10′视力2.0的视角是0.5′可以推算出，在视力1.0视角是1′的基础上视角放大几倍就是视力数值除以几视角缩小几倍就是视力数值乘以几可以计算出8.19′的视角对应的视力数值是1÷8.19≈0.12手机前置摄像头的视力达到0.12就可以距离眼睛30厘米拍摄到用户眼睛中手机壳前边框宽度并成像为1像素。前面推算出前置摄像头视力为0.5以上，那么可以成像为4像素以上。可以推断出现在流行的手机基本都可以通过前摄摄像头解析到用户角膜中的手机壳的倒影。这只是理论数据，实际当中可能会有下面几个影响因素：光线太弱导致成像不清楚摄像头像素达到了，但是解析能力太差，导致成像不清楚最主要是，角膜并镜子，对光线的反射能力太差，导致倒影发虚但是手机将图像数字化后，可以分析图像的颜色数值来精确判断，即使一点色差都可以察觉到，所以这个或许可以实现。主要还是看手机对图像的的捕捉和解析能力。结论通过分析，这个需求也并不是完全不可能实现，只是对技术以及硬件的要求都很高。声明本文为本人原创，数据分析计算过程中可能存在错误。如需转载请注明原文地址，谢谢~</li>
  <li>前言初次听到oc与js交互时，你可能会觉得这是一种高深的技术，其实不然，它并不高深，也很好学，oc与js交互还有另外一个很高大上的名字叫Hybrid开发。苹果提供了一个JavaScriptCore框架，用于oc与js交互，里面主要有这几个类JSContext：给JavaScript提供运行的上下文环境JSValue：JavaScript和Objective-C数据和方法的桥梁JSManagedValue：管理数据和方法的类JSVirtualMachine：处理线程相关，使用较少JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议下面我用最少的代码来实现js交互，为的就是让小白快速学会js交互，大神可以略过。。。这几个类不会全部用到，如果你感兴趣，可以看一下官方文档，深入学习。js与oc交互，就是网页与原生代码互相调用，首先我们创建一个含有js代码的网页js.html,里面有三个按钮，当点击按钮的时调用原生方法。js.html源码如下&lt;scripttype="text/javascript"&gt;functionbuttonClick1(){ocObject.buttonClick();}functionbuttonClick2(){ocObject.buttonClick2("给我打印这个字符串");}functionbuttonClick3(){ocObject.buttonClick3("参数1","参数2","参数3");}&lt;/script&gt;&lt;buttononclick="buttonClick1()"&gt;调无参方法&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;&lt;buttononclick="buttonClick2()"&gt;调1个参方法&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;&lt;buttononclick="buttonClick3()"&gt;调3个参方法&lt;/button&gt;创建一个与js交互的原生类JSClass,定义一个协议JSClassDelegate继承自协议JSExport，JSClassDelegate中定义了js调用的方法，JSClass需遵守该协议才能与js交互。JSClass.h源码如下#import&lt;Foundation/Foundation.h&gt;#import&lt;JavaScriptCore/JavaScriptCore.h&gt;@protocolJSClassDelegate&lt;JSExport&gt;-(void)buttonClick;-(void)buttonClick2:(NSString*)arg;-(void)buttonClick3:(NSString*)arg1:(NSString*)arg2:(NSString*)arg3;@end@interfaceJSClass:NSObject&lt;JSClassDelegate&gt;@endJSClass.m源码如下#import"JSClass.h"@implementationJSClass-(void)buttonClick{NSLog(@"点击了按钮");}-(void)buttonClick2:(NSString*)arg{NSLog(@"%@",arg);}-(void)buttonClick3:(NSString*)arg1:(NSString*)arg2:(NSString*)arg3{NSLog(@"%@",arg1);NSLog(@"%@",arg2);NSLog(@"%@",arg3);}@end有了html页面和JSClass，下面就可以将它们绑定起来了。直接上代码#import"ViewController.h"#import"JSClass.h"@interfaceViewController()&lt;UIWebViewDelegate&gt;@property(nonatomic,weak)UIWebView*webView;@end@implementationViewController-(void)viewDidLoad{[superviewDidLoad];NSString*path=[[NSBundlemainBundle]pathForResource:@"js"ofType:@"html"];NSString*content=[[NSStringalloc]initWithContentsOfFile:pathencoding:NSUTF8StringEncodingerror:nil];if(content.length==0)return;UIWebView*webView=[[UIWebViewalloc]init];webView.delegate=self;[self.viewaddSubview:webView];self.webView=webView;[webViewloadHTMLString:contentbaseURL:nil];//Doanyadditionalsetupafterloadingtheview,typicallyfromanib.}-(void)webViewDidFinishLoad:(UIWebView*)webView{//获取js上下文对象JSContext*context=[webViewvalueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];//创建与js绑定的原生对象JSClass*jsObject=[JSClassnew];//原生对象传给jscontext[@"ocObject"]=jsObject;}-(void)viewDidLayoutSubviews{[superviewDidLayoutSubviews];self.webView.frame=self.view.bounds;}-(void)didReceiveMemoryWarning{[superdidReceiveMemoryWarning];//Disposeofanyresourcesthatcanberecreated.}@end效果我们来运行一下有点丑，但是不影响我们调试功能依次点击三个按钮后打印信息如下2018-08-0216:06:03.116370+0800Hybrid_demo[31435:3830397]调用了oc的无参方法2018-08-0216:06:04.581703+0800Hybrid_demo[31435:3830397]给我打印这个字符串2018-08-0216:06:05.485736+0800Hybrid_demo[31435:3830397]参数12018-08-0216:06:05.486490+0800Hybrid_demo[31435:3830397]参数22018-08-0216:06:05.487110+0800Hybrid_demo[31435:3830397]参数3说明js已经成功调用了原生方法，是不是soeasy源码地址：https://github.com/delims/Hybrid_demo.git欢迎转载，转载请注明原文地址，谢谢~</li>
  <li>辛苦发布了CocoaPods框架后，通过podsearch却搜不到，别着急，下面这个方法或许可以帮到你search_index.json文件是podsearch搜索时的缓存文件，删除search_index.jsonrm~/Library/Caches/CocoaPods/search_index.json打开终端重新使用podsearch搜索你的框架,这时search_index.json缓存文件会被重新生成,你的框架就可以搜索出来了。</li>
  <li>前言开发一个cell高度不确定的列表，我们通常的做法是给cell设置一个自上到下的约束，然后设置UITableView的rowHeight属性为UITableViewAutomaticDimension，这样cell就可以根据内容自适应高度，正常情况下是没有问题的。前段时间我开发一个类似微信朋友圈的列表，cell上面有label和图片展示控件，图片展示控件是我自己封装的，取名为TXShowFileView，继承自UICollectionView的九宫格图片展示控件，也支持视频和附件。把TXShowFileView放在xib中，设置四周约束，这样整个cell自上到下的约束就设置完了，在给cell设置model的时候，会传值给TXShowFileView一组附件模型，TXShowFileView根据附件模型的类型和数量，自动计算自身大小，然后设置自身的高度约束。这样就可以确定cell的高度了。起初是没有问题的，后来发现在滑动的时候会报一个警告，如下:"&lt;NSLayoutConstraint:0x1c0482bc0UIImageView:0x1167efd90.height==36&gt;","&lt;NSLayoutConstraint:0x1c0a8b8b0TXAddFileView:0x1089ebc00.height==80.3333&gt;","&lt;NSLayoutConstraint:0x1c0a8bcc0UIImageView:0x1167efd90.top==TXMView:0x1167efba0.top+12&gt;","&lt;NSLayoutConstraint:0x1c0484dd0UILabel:0x1167effc0.top==UIImageView:0x1167efd90.top&gt;","&lt;NSLayoutConstraint:0x1c0484e20UILabel:0x1167effc0.centerY==UIImageView:0x1167efd90.centerY-10&gt;","&lt;NSLayoutConstraint:0x1c0a8be00UILabel:0x1167f02a0.top==UILabel:0x1167effc0.bottom+5&gt;","&lt;NSLayoutConstraint:0x1c0484ec0UILabel:0x1167f0b40.top==UILabel:0x1167f02a0.bottom+18&gt;","&lt;NSLayoutConstraint:0x1c0a8bfe0TXMView:0x1167efba0.bottom==TXAddFileView:0x1089ebc00.bottom+16&gt;","&lt;NSLayoutConstraint:0x1c0a8c080TXAddFileView:0x1089ebc00.top==UILabel:0x1167f0b40.bottom+12&gt;","&lt;NSLayoutConstraint:0x1c0485000TXMView:0x1167efba0.top==UITableViewCellContentView:0x1167ef580.top&gt;","&lt;NSLayoutConstraint:0x1c0a8c300UITableViewCellContentView:0x1167ef580.bottom==TXMView:0x1167efba0.bottom&gt;","&lt;NSLayoutConstraint:0x1c0a8cda0UITableViewCellContentView:0x1167ef580.height==101&gt;"这个警告的出现会发生在有附件的cell重用为没有附件的cell时。或者没有附件的cell重用为有附件的cell时。没有附件时TXShowFileView的高度为零。你可能会想到我设置TXShowFileView的高度约束时，cell已经返回了。然而并不是这样的。返回cell时，高度约束已经设置完了。一般出现这种警告往往就是约束冲突，你需要去掉一个引起冲突的约束。看着这个警告，我正准备从头到尾的排查一下到底是哪个约束出现了问题时。我注意到最后一行&lt;NSLayoutConstraint:0x1c0a8cda0UITableViewCellContentView:0x1167ef580.height==101&gt;很明显这是给cell的ContentView添加的约束，然而我并没有添加这个约束，我猜想这可能是系统计算出cell的高度，然后自己添加的。这样一来，系统自己给cell添加了一个高度约束，而我给cell子视图添加的自上到下的约束已经确定了cell的高度了，所以就出现了约束冲突。就算是添加了两次高度约束，那这两个高度应该是一样的啊，为什么还冲突呢，我也不知道，但是我想到了一个解决办法。想到系统添加的约束应该比较强势的，UILayoutPriorityRequired。那我就TXShowFileView的高度约束设置为UILayoutPriorityDefaultHigh试试。果然，通过调试发现没有报警告了。正常使用autolayout约束应该是非常清晰明确有条理的，这样才不会导致约束冲突，但是有些情况下难免会出现约束冲突，这时候可以适当的降低一下约束的权重来避免冲突。</li>
</ul>