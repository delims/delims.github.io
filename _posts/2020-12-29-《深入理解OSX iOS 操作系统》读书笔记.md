---
layout: post
author: delims
categories: iOS
---

# 第一章 达尔文主义：OS X 的进化史

### 协作式多任务系统 和 抢占式多任务系统

- 协作式多任务系统

只要进程获得了CPU的使用权，除非它放弃使用CPU，不然就会一直霸占着CPU，所以需要各个进程协作使用一段时间CPU，然后放弃使用，系统才能正常运行，如果一个进程发生死锁，系统也就崩溃了。

- 抢占式多任务系统

1. 总控制权在操作系统手中，操作系统轮流询问进程是否需要使用CPU，需要就让用，不过在用了一段时间后，系统会剥夺进程的CPU使用权，让其他进程使用。
2. 系统根据进程的优先级才排定优先顺序，具有高优先级的进程就是当前执行的线程。
3. 当前线程什么时候结束？① 属于该线程的时间片结束。② 加入了另一个优先级更高的进程。

### macOS 历史

- Mac OS Classic 是 MacOS 在 OSX 之前的名称。
- 1997年，当时只有一个没有任何发展前途操作系统的苹果公司收购了NeXT公司。
- Mac OS Classic 和 NeXTSTEP 结合变成了 OSX 

# 第二章 合众为一：OS X 和 iOS 的架构。

- 框架就是一种特殊形式的库，框架更倾向于OSX 和 iOS 特有的，而库则是所有UNIX系统共有的。
- OSX 和 iOS 将传统的库保存在 /usr/lib 。库的后缀是 .dylib 
- 而其他Unix系统的库是.so 
- 核心C库libc被吸收到苹果自己的libSystem.B.dylib中。这个库还包含了数据库 libm 和 libpthread 以及其他一些库提供的功能。

## 系统调用

- 作为所有操作系统都遵守的准则，用户程序不予许直接访问系统资源。用户程序可以操作通用寄存器，执行一些简单的计算，但是如果需要执行重要的功能，例如：打开文件或者 socket，甚至是发送一条简单的消息，都必须使用系统调用。
- 系统调用指的是由内核导出的预定义函数的入口点。
- 在用户态需要连接 libSystem.B.dylib 才能访问这些系统调用。
- OS X的系统调用特殊之处在于道出了两套系统调用接口，一个是Mach调用，一个是POSIX调用。

> POSIX (Portable Operating System Interface) 是一套标准的API。具体定义了一下内容。

- **系统调用原型** ：所有POSIX系统调用，不论底层如何实现，都有相同的原型，也就是说具有相同的参数和返回值。所以只要是POSIX兼容的代码就可以在任何兼容POSIX的系统上移植。
-  **系统调用编号**：除了固定的原型之外，POSIX 还完整定义了系统调用的编号。这在一定程度上允许了二进制层次的可以执行。也就是说POSIX兼容的二进制代码可以在底层架构相同的的POSIX系统之间移植。前提是两个系统的目标文件格式一致。

POSIX 兼容性是由 XNU 中 BSD 层提供的。这个系统调用原型在 <unistd.h> 头文件中。

## Mach 系统调用

OS X 是在 Mach 内核的基础上构建的，而 Mach 是 NeXTSTEP 的遗产。BSD 层是对 Mach 内核的包装。但是 Mach系统调用仍然可以在用户态访问。

- 在 32 位系统上， Mach 系统调用的编号为负数。
- 这样可以使得 POSIX 和 Mach 系统调用共存。由于 POSIX 只定义了非负数的系统调用。福数空间没有使用，因此 Mach 就使用了负数。
- 在 64 位系统上，Mach 系统调用是正数，但是以 **0x200 0000** 开头，而 POSIX 调用编号以 **0x100 0000** 开头，所以两者可以明显区分开。
- 系统调用不是直接调用的，而是通过 libSystem.B.dylib 中的浅层封装进行的。

## XNU 概述

内核 XNU 是 Darwin 的核心，也是整个OS X 的核心。XNU 本身由一下几个部分组成。

- Mach 微内核
- BSD 层
- libKern
- I/O Kit

内核是模块化的，允许根据需要动态加载内核扩展 KExt.

> Mach 

XNU 的核心。Mach 微内核的职责。

- 进程和线程抽象
- 虚拟内存管理
- 任务调度
- 进程间通信和消息传递机制

> BSD 层

BSD 层建立在 Mach 之上，也是 XNU 中一个不可分割的部分。这一层是一个很可靠且更现代化的 API。提供了POSIX 兼容性。BSD 层提供了更高层次的抽象。其中包括：

- UNIX 进程模型
- POSIX 线程模型以及其他相关同步原语
- UNIX 用户和租
- 网络协议栈（BSD Socket API)
- 文件系统访问
- 设备访问（通过/dev 目录访问）

XNU 中的BSD 实现很大程度上和 FreeBSD 的实现兼容。

# 站在巨人的肩膀上：OS X 和 iOS 使用的技术

> 强制访问控制

FreeBSD 5.x 最早引入了一项强大的安全特性：Mandatory Access Control ,强制访问控制MAC，允许更为精细的安全模型，添加对象级别的安全性。通过这种方式，可以控制一个给定的应用程序不允许访问用户的私有数据或某些网站。

MAC 是 OS X的隔离机制，即沙盒和 iOS的 entitlement机制的基础。

- 特洛伊木马，木马程序需要在无知的用户配合下才能工作。

- 代码签名在OSX 中是可选的，但是在 iOS 中是强制的。

# 庖丁解进程：Mach-O 格式、进程以及线程内幕

- 线程只不过是一组寄存器的状态。
- 信号是一种软件中断，表示进程发生了异常，或者发生了外部事件。
- 信号是指发给程序的异步通知，其中不包含数据或者只包含非常少的数据。
- 信号是由操作系统发送给进程的，用于表示发生了某种条件，而这种条件通畅是因为某类硬件错误或者程序异常引起的。
- 代码注入的常见方法就是使用栈变量（自动变量），因此默认情况下栈都标记为不可执行，MH_ALLOW_STACK_EXECUTION 可以让栈可执行。堆默认情况下是可执行。堆默认情况下是可执行，MH_NO_HEAP_EXECUTION 可以让标记堆不可执行。

> 加载命令

- Mach-O 文件头中包含了非常详细的加载指令，这些指令在被调用时清晰地指导了如何设置并加载二进制数据。

- 加载过程在内核的部分负责新进程的基本设置——分配虚拟内存，创建主线程，以及处理任何可能的代码签名/加密工作。然而对于动态链接的可执行文件（大部分可执行文件都是动态链接的）来说，真正的库加载和符号解析的工作都是通过 LC_LOAD_DYLINKER 命令指定的动态连接器在用户态完成的。控制权会转交给连接器，连接器进而接着处理文件头中其他的加载命令。

> 加载命令详解

-  LC_SEGMENT 或者 LC_SEGMENT_64

最主要的加载命令，这条命令指导内核如何设置新运行的进程的内存空间。这些段直接从 Mach-O 二进制文件加载到内存中。

每一条LC_SEGMENT(_64)命令都提供了段布局所有必要细节信息。

1. **vmaddr** 所描述段的虚拟起始地址
2. **vmsize** 所描述段的虚拟内存大小
3. **fileoff** 表示这个段在文件中的偏移量
4. **filesize** 表示这个段在文件中占用的字节数
5. **maxprot** 段的页面表示的最高内存保护
6. **initprot** 段的页面最初始的内存保护
7. **nsects** 段中section的数量
8. **flags** 杂项标志位

- LC_MAIN

设置程序主线程入口点地址和栈大小，设置寄存器状态，除了指令指针寄存器，其他都设置为0

- LC_CODE_SIGNATURE

包含了 Mach-O 二进制文件的代码签名，如果这个签名和代码本身不匹配或者在 iOS 上这条命令不存在，内核会直接给进程发送一个 SIGKILL 信号将进程杀死。

- LC_DYLINKER 

动态连接器是内核执行 LC_DYLINKER 加载命令启动的，通常事情下使用的是 /usr/lib/dyld 作为动态加载器，不过这条命令可以指定任何程序作为加载器，内核将进程的入口点设置为连接器的入口点，由连接器接管刚创建的进程的控制权。

> 启动时库的加载

只有少量进程只需要内核加载器就可以完成，几乎所有OS X上程序都是动态链接的，Mach-O 镜像中有很多空洞，即对外部库和符号的引用，这些空洞要在程序启动时填补。这项动作就需要由动态连接器来完成。这个过程有时候也称为符号绑定 （binding）。

- 如果二进制文件中使用了外部定义的函数和符号，那么在他们的 TEXT 段中会有一个名为 __stubs （桩）的区，在这个区中存放的是这些本地未定义符号的占位符。













