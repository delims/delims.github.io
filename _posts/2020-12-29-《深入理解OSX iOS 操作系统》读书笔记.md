---
layout: post
author: delims
categories: iOS
---

# 第一章 达尔文主义：OS X 的进化史

### 协作式多任务系统 和 抢占式多任务系统

- 协作式多任务系统

只要进程获得了CPU的使用权，除非它放弃使用CPU，不然就会一直霸占着CPU，所以需要各个进程协作使用一段时间CPU，然后放弃使用，系统才能正常运行，如果一个进程发生死锁，系统也就崩溃了。

- 抢占式多任务系统

1. 总控制权在操作系统手中，操作系统轮流询问进程是否需要使用CPU，需要就让用，不过在用了一段时间后，系统会剥夺进程的CPU使用权，让其他进程使用。
2. 系统根据进程的优先级才排定优先顺序，具有高优先级的进程就是当前执行的线程。
3. 当前线程什么时候结束？① 属于该线程的时间片结束。② 加入了另一个优先级更高的进程。

### macOS 历史

- Mac OS Classic 是 MacOS 在 OSX 之前的名称。
- 1997年，当时只有一个没有任何发展前途操作系统的苹果公司收购了NeXT公司。
- Mac OS Classic 和 NeXTSTEP 结合变成了 OSX 

# 第二章 合众为一：OS X 和 iOS 的架构。

- 框架就是一种特殊形式的库，框架更倾向于OSX 和 iOS 特有的，而库则是所有UNIX系统共有的。
- OSX 和 iOS 将传统的库保存在 /usr/lib 。库的后缀是 .dylib 
- 而其他Unix系统的库是.so 
- 核心C库libc被吸收到苹果自己的libSystem.B.dylib中。这个库还包含了数据库 libm 和 libpthread 以及其他一些库提供的功能。

## 系统调用

- 作为所有操作系统都遵守的准则，用户程序不予许直接访问系统资源。用户程序可以操作通用寄存器，执行一些简单的计算，但是如果需要执行重要的功能，例如：打开文件或者 socket，甚至是发送一条简单的消息，都必须使用系统调用。
- 系统调用指的是由内核导出的预定义函数的入口点。
- 在用户态需要连接 libSystem.B.dylib 才能访问这些系统调用。
- OS X的系统调用特殊之处在于道出了两套系统调用接口，一个是Mach调用，一个是POSIX调用。

> POSIX (Portable Operating System Interface) 是一套标准的API。具体定义了一下内容。

- **系统调用原型** ：所有POSIX系统调用，不论底层如何实现，都有相同的原型，也就是说具有相同的参数和返回值。所以只要是POSIX兼容的代码就可以在任何兼容POSIX的系统上移植。
-  **系统调用编号**：除了固定的原型之外，POSIX 还完整定义了系统调用的编号。这在一定程度上允许了二进制层次的可以执行。也就是说POSIX兼容的二进制代码可以在底层架构相同的的POSIX系统之间移植。前提是两个系统的目标文件格式一致。

POSIX 兼容性是由 XNU 中 BSD 层提供的。这个系统调用原型在 <unistd.h> 头文件中。

## Mach 系统调用

OS X 是在 Mach 内核的基础上构建的，而 Mach 是 NeXTSTEP 的遗产。BSD 层是对 Mach 内核的包装。但是 Mach系统调用仍然可以在用户态访问。

- 在 32 位系统上， Mach 系统调用的编号为负数。
- 这样可以使得 POSIX 和 Mach 系统调用共存。由于 POSIX 只定义了非负数的系统调用。福数空间没有使用，因此 Mach 就使用了负数。
- 在 64 位系统上，Mach 系统调用是正数，但是以 **0x200 0000** 开头，而 POSIX 调用编号以 **0x100 0000** 开头，所以两者可以明显区分开。
- 系统调用不是直接调用的，而是通过 libSystem.B.dylib 中的浅层封装进行的。

## XNU 概述

内核 XNU 是 Darwin 的核心，也是整个OS X 的核心。XNU 本身由一下几个部分组成。

- Mach 微内核
- BSD 层
- libKern
- I/O Kit

内核是模块化的，允许根据需要动态加载内核扩展 KExt.

> Mach 

XNU 的核心。Mach 微内核的职责。

- 进程和线程抽象
- 虚拟内存管理
- 任务调度
- 进程间通信和消息传递机制

> BSD 层

BSD 层建立在 Mach 之上，也是 XNU 中一个不可分割的部分。这一层是一个很可靠且更现代化的 API。提供了POSIX 兼容性。BSD 层提供了更高层次的抽象。其中包括：

- UNIX 进程模型
- POSIX 线程模型以及其他相关同步原语
- UNIX 用户和租
- 网络协议栈（BSD Socket API)
- 文件系统访问
- 设备访问（通过/dev 目录访问）

XNU 中的BSD 实现很大程度上和 FreeBSD 的实现兼容。

# 站在巨人的肩膀上：OS X 和 iOS 使用的技术

> 强制访问控制

FreeBSD 5.x 最早引入了一项强大的安全特性：Mandatory Access Control ,强制访问控制MAC，允许更为精细的安全模型，添加对象级别的安全性。通过这种方式，可以控制一个给定的应用程序不允许访问用户的私有数据或某些网站。

MAC 是 OS X的隔离机制，即沙盒和 iOS的 entitlement机制的基础。

- 特洛伊木马，木马程序需要在无知的用户配合下才能工作。

- 代码签名在OSX 中是可选的，但是在 iOS 中是强制的。

# 庖丁解进程：Mach-O 格式、进程以及线程内幕

- 线程只不过是一组寄存器的状态。
- 信号是一种软件中断，表示进程发生了异常，或者发生了外部事件。
- 信号是指发给程序的异步通知，其中不包含数据或者只包含非常少的数据。
- 信号是由操作系统发送给进程的，用于表示发生了某种条件，而这种条件通畅是因为某类硬件错误或者程序异常引起的。
- 代码注入的常见方法就是使用栈变量（自动变量），因此默认情况下栈都标记为不可执行，MH_ALLOW_STACK_EXECUTION 可以让栈可执行。堆默认情况下是可执行。堆默认情况下是可执行，MH_NO_HEAP_EXECUTION 可以让标记堆不可执行。

### 加载命令

- Mach-O 文件头中包含了非常详细的加载指令，这些指令在被调用时清晰地指导了如何设置并加载二进制数据。

- 加载过程在内核的部分负责新进程的基本设置——分配虚拟内存，创建主线程，以及处理任何可能的代码签名/加密工作。然而对于动态链接的可执行文件（大部分可执行文件都是动态链接的）来说，真正的库加载和符号解析的工作都是通过 LC_LOAD_DYLINKER 命令指定的动态连接器在用户态完成的。控制权会转交给连接器，连接器进而接着处理文件头中其他的加载命令。

### 加载命令详解

-  LC_SEGMENT 或者 LC_SEGMENT_64

最主要的加载命令，这条命令指导内核如何设置新运行的进程的内存空间。这些段直接从 Mach-O 二进制文件加载到内存中。

每一条LC_SEGMENT(_64)命令都提供了段布局所有必要细节信息。

1. **vmaddr** 所描述段的虚拟起始地址
2. **vmsize** 所描述段的虚拟内存大小
3. **fileoff** 表示这个段在文件中的偏移量
4. **filesize** 表示这个段在文件中占用的字节数
5. **maxprot** 段的页面表示的最高内存保护
6. **initprot** 段的页面最初始的内存保护
7. **nsects** 段中section的数量
8. **flags** 杂项标志位

- LC_MAIN

设置程序主线程入口点地址和栈大小，设置寄存器状态，除了指令指针寄存器，其他都设置为0

- LC_CODE_SIGNATURE

包含了 Mach-O 二进制文件的代码签名，如果这个签名和代码本身不匹配或者在 iOS 上这条命令不存在，内核会直接给进程发送一个 SIGKILL 信号将进程杀死。

- LC_DYLINKER 

动态连接器是内核执行 LC_DYLINKER 加载命令启动的，通常事情下使用的是 /usr/lib/dyld 作为动态加载器，不过这条命令可以指定任何程序作为加载器，内核将进程的入口点设置为连接器的入口点，由连接器接管刚创建的进程的控制权。

### 启动时库的加载

只有少量进程只需要内核加载器就可以完成，几乎所有OS X上程序都是动态链接的，Mach-O 镜像中有很多空洞，即对外部库和符号的引用，这些空洞要在程序启动时填补。这项动作就需要由动态连接器来完成。这个过程有时候也称为符号绑定 （binding）。

- 如果二进制文件中使用了外部定义的函数和符号，那么在他们的 TEXT 段中会有一个名为 __stubs （桩）的区，在这个区中存放的是这些本地未定义符号的占位符。


### OSX 的 dyld 环境变量

- DYLD\_INSERT\_LIBRARIES 

在程序加载时强行插入一个或多个库——和 Unix 上的 LD_PRELOAD 思想相同。强制地将一个库注入新创建进程的地址空间。

### 64位地址空间

- 64位并不是真正的64位。由于虚拟地址到物理地址转换的开销，Intel 架构只使用了 48 位的虚拟地址。这是硬件上的限制，Linux 和 Windows都会受到这个限制的约束。因此用户内存空间可以访问的区域最高到 0x7FFF-FFFF-FFFF
- 64位模式下，可以将内核地址空间映射到每一个进程的地址空间，而在32位模式下内核是单独的地址空间。

### 内存的几个段

- **\_\_PAGEZERO**

1. 在 32 位系统中，这是内存中单独是一个页面（4KB），而且这个页面所有的访问权限都被撤销了，即没有任何访问权限。
2. 在 64 位系统上，这个段对应一个完整的 32 位地址空间——即前 4GB。
3. 这个段有足浴捕捉空指针引用，因为空指针实际上就是0，或者捕捉将整数做指针引用（32 位平台下的 4095 以下的值，以及 64 位平台下的 4GB 以下的值都在这个范围）。
4. 这个范围内才的所有访问权限都没有，所以在这个范围内的任何解引用操作都会引发来自 MMU 的硬件页错误，进而产生一个内核可以捕捉的陷阱。内核将这个陷阱转换为 C++ 异常或表示总线错误的 POSIX 信号 SIGBUS。
5. 可以通过 MachOView 看到 pagezero 的段起始地址为 0，段大小为 4GB，文件大小为 0

- **\_\_TEXT**

1. 这个段存放的程序代码。和其他操作系统一样，文本段被设置为 r-x，即只读且可执行。
2. 这不仅可以防止二进制代码在内存中被修改，还可以通过共享这个只读文本段优化内存使用。
3. 通过这种方式，同一个程序的多个实例可以仅使用一份 \_\_TEXT 副本。
4. 文本段通常包含多个区，实际的代码在 \_text 区中。
5. 文本段还包含其他只读数据，例如常量和硬编码的字符串。

- **\_\_LINKEDIT** 

由 dyld 使用，这个区包含了字符串表、符号表以及其他数据

- **\_\_IMPORT** : 用于 i386 的二进制文件的导入表。
- **\_\_DATA**：用于可读写的数据。
- **\_\_MALLOC\_TNY**：用于小于一个页面的内存分配。
- **\_\_MALLOC\_SMALL**：用于几个页面大小的内存分配。
- **\_\_MALLOC\_LARGE**：用于 1MB 以上大小的内存分配。

有一个段不会被 vmmap 显示出来，那就是 **commpage**。 这个段包含了一组内核导出给用户态的页面，类似于 Linux 中 vsyscall 和 vdso 的概念。这些页面在所有进程中是共享的，并且在固定的地址位置。在 i386 上 为 0xffff0000， 在 x86_64 上为 0x7fffffe00000 ，在 ARM 上为 0x40000000。这些页面包含了各种和 CPU 以及平台相关的函数。

### alloca

使用 alloca() 可以用栈来动态分配内存。这个函数原型 和 malloc 一样，区别在于这个函数返回的指针是栈上的地址。

- 栈中分配空间通常情况下只不过是简单的修改栈指针寄存器。这比遍历堆空间并试图找到一个合适的区域或者空间列表并从中活的一个内存块要快得多。
- 栈内存的页面已经在内存中了，不用担心页面错误的问题。尽管在用户态感觉不到发生了缺页错误，但是在性能上却有重大影响。
- 当分配了空间的函数返回时，栈中分配的空间会自动释放。这是由函数调用约定的开端和收尾确保的。
- 虽然动态分配栈内存可以提高性能，但是栈空间十分有限。只适合对小空间的分配。


### 页面是生命周期

物理内存页面的生命周期包含几个状态

- **free(空闲)** ：物理页面没有被任何虚拟内存页面使用。
- **Active(活跃)** ：物理页面当前正在被一个虚拟内存页面使用，而且最近被引用过。
- **Inactive(非活跃)** ：物理页面当前正在被一个虚拟内存页面使用，但是最近没有被引用过。
- **Speculative(投机)** ：页面被投机映射。产生这个状态的原因是针对可能的内存需求做了一次猜测的分配。
- **Wired down(联动)**：物理页面当前正在被一个虚拟内存页面使用，但是不能被交换出去。

### 线程

线程是过去时代的产物。进程是系统执行的基本单元，而且是执行过程中所需要的各种资源，包括虚拟内存、文件描述符以及其他各种对象。开发者编写顺序程序，从入口点 —— main 开始执行，直到 main 函数返回或者调用 exit() 。

然而这种方法很快被证明太刻板，对于需要并发执行的任务来说灵活性太低。需要并发执行的任务中很重要的一部分就是带有 I/O 的任务：像 read 和 write 这样的操作可能会被永久的阻塞。特别是针对 socket 的操作。阻塞的读操作意味着在 socket 代码在等待读入时候不能持续发送数据。

大部分进程早晚都会在 I/O 上阻塞。I/O 操作意味着进程中时间片大部分都被放弃了。这对性能有很大的影响，因为进程的上线文切换开销很大。

### 线程

线程，作为最大化利用进程时间片的方法，应运而生。通过使用多线程，任务的执行表面上可以看到并发的多任务，当一个任务阻塞了，可以把剩下的时间片分配给其他并发的子任务。

线程之间的切换比较小——只需要保存和恢复寄存器即可。

进程的钱还还需要切换虚拟地址空间，其中包括很多地城的开销，例如清空 cache 和 TLB。

多核处理器更适合线程，因为多个处理器核心共享同样的 cache 和 RAM —— 这为进程之间共享虚拟内存提供了基础。相比之下多处理器架构可能因为非一致性的内存架构和 cache 一致性方面的原因损失一些性能。

### POSIX 线程

POSIX 线程模型实际上是除了 Windows 之外所有系统使用的线程 API。Windows 坚持提供 win32 线程 API。

# 引导过程：EFI 和 iBoot

引导过程指的是从计算机通电那一瞬间到 CPU 开始执行操作系统代码时的整个过程，这个过程往往是系统启动过程中被忽略的一部分。在这个非常初期的阶段中，CPU 执行标准的启动代码。这部分代码需要对硬件设备进行探测，寻找最优可能启动的操作系统并且根据用户定义的参数启动这个操作系统。

其他操作系统用的都是默认的引导加载器 boot loader, 而 iOS 和 OS X 使用的则是自己的引导加载器。

BIOS 是一个固定的程序，而且通常的封闭的。EFI 是一套接口。EFI 更像是运行时环境。

- EFI 程序——不论是应用程序、引导加载器还是驱动程序——就是一个二进制程序。
- EFI 二进制程序采用的便携式可执行格式（Portable Executable, PE）。这个格式是微软采用的可执行格式。
































