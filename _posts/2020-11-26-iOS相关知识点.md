---
layout: post
author: delims
categories: iOS
---

# 关联对象

- ObjcAssociation 结构体保存了关联policy和关联value
- ObjcAssociationMap 以关联key为key ,以 ObjcAssociation 为 value
- ObjcAssociationHashMap 为全局的 map。其中 key为关联对象的伪装指针。value 为 ObjcAssociationMap

# KVO

- 当给A的实例添加observer的时候，系统动态创建名为 NSKVONotifying_A 的A的子类。
- NSKVONotifying_A 重写了父类的setter方法。
- setter方法的前后添加了 willChangeValueForKey 和 didChageForKey 。
- A的 instance 的 isa 指针指向NSKVONotifying_A这个类。
- 当调用A的setter方法的时候，由于isa指针指向了NSKVONotifying_A，所以会调用 NSKVONotifying_A 的setter方法，NSKVONotifying_A的setter方法中调用super的setter方法，这时候会调用A的setter方法。
- 调用setValue: forKey 会调用对应的setter方法，所以对KVO有效

#KVC 

- 调用 valueForKey 时，会判断 相关getter方法是否存在，如果存在直接调用
- 如果不存在，会调用 +(BOOL)accessInstanceVariablesDirectly 方法。
- 方法返回如果方法返回NO，说明不允许方法成员变量会抛出一个NSUnknownKeyException 的异常。
- 如果方法返回YES，说明可以访问成员变量，然后判断没有对应的成员变量，判断顺序依次为： \_key key \_isKey isKey。如果找到了。直接访问。
- 调用 setValue: forKey 也会调用 +(BOOL)accessInstanceVariableDirectly 进行判断是否可以访问成员变量。

# Block

- \_\_NSGlobalBlock\_\_ 调用 copy 操作什么也不做，因为本来就在代码区，复制那么多也没用。
- \_\_NSMallocBlock\_\_ 调用 copy 操作引用计数+1，本来就在堆里，复制多了也没用，引用计数+1 即可。
- \_\_NSStackBlock\_\_ 调用 copy 操作复制到堆上，变成堆block。为了防止函数返回后销毁，所以放到堆里。


## ARC环境下，什么情况下编译器会把 stack 上的block复制到 heap上

1. block 作为函数返回值。
2. 将block 复制给 __strong  指针。
3. block作为usingblock时。
4. block作为GCD API的方法参数时。
5. 
