---
layout: post
author: delims
categories: iOS
---

- cin 和 cout 分别是 ostream 和 istream 的对象，是内置对象，是由标准库的开发者提前创建好的。

- endl 表示换行，功能等同于 "\n"。

- C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。

- C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。和 malloc() 一样，new 也是在堆区分配内存，必须手动释放

```
int *p = new int;  //分配1个int型的内存空间
delete p;  //释放内存

```

- new 操作符会根据后面的数据类型来推断所需空间的大小。如果希望分配一组连续的数据，可以使用 new[]，用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。

```
int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
```

- C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。

```
float d = 10.8;
void func(int n, float b=d+2.9, char c='@'){
    cout<<n<<", "<<b<<", "<<c<<endl;
}
```

- 使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。
- 使用初始化列表来初始化字段 Line::Line( double len): length(len)。

- 一个派生类继承了所有的基类方法，但下列情况除外：

1. 基类的构造函数、析构函数和拷贝构造函数。
2. 基类的重载运算符。
3. 基类的友元函数。

- **虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。
 
 - 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到**纯虚函数**。

```
	virtual int area() = 0;
```

= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。

- 数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。


- 默认情况下，在类中定义的所有项目都是私有的。
- C++ 接口是使用抽象类来实现的。
- 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。
- 抽象类不能被用于实例化对象。
- 抽象类的子类必须实现每一个**虚函数**。


- new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 

- 我用g++编译器发现C++ 检查数组越界。

# const 

-  int get() const{return i;} //get函数返回i的值，不需要对i进行修改，则可以用const修饰。防止在函数体内对i进行修改。
-  const成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数。

- const修饰的函数参数是指针时,代表在函数体内不能修改该指针所指的内容，起到保护作用。

```
//保护源字符串不被修改，若修改src则编译出错。  
void fun(const char * src, char * des)
{   
	strcpy(des,src);  
}  
```


- \# 和 ## 运算符，#处理成字符串，## 连接作用

> C++ 信号处理

| 信号 | 描述 |
| ---- | ---- | 
| SIGABRT | 程序的异常终止，如调用 abort |
| SIGFPE | 错误的算术运算导致，比如除以 0 |
| SIGILL | 检测到非法指令 |
| SIGINT | 程序终止（interrupt）信号 |
| SIGSEGV | 非法访问内存 |
| SIGTERM | 发送到程序的终止请求 |

- 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。

> static 关键字作用

1. 声明静态局部变量
2. 声明全局变量时限制作用域为本文件。
3. 修改类成员变量时，所有对象共享。

- 使用 thread_local 说明符声明的变量仅可在创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

> 隐式调用，声明类直接复制，等于隐式调用对应构造函数。
> 加上关键字 explicit 可以禁止隐式调用。

```
Apple apple = 10;// 隐式调用Apple(int size)

explicit Apple(int size);//禁止隐式调用

```

# C++ 中 class 和 struct 的区别

- 默认的**继承访问权限**。class是 private ，struct 是public 。
- class 和 struct 可以相互继承。
- 使用哪种权限取决于子类。子类是 class 继承 struct 是private 继承。struct 继承 class 就是 public 继承。总之子类是 class 不管父类是什么，都是private 继承。子类是struct 不管父类是什么都是public继承。 这是默认的权限。也可以显式指定是 public 、 protected 和 private。

- 默认的数据访问权限。struct 是 public 的。 class 是private 。
- 也就是说类成员定的时候如果不显式指定访问权限。class的所有程序都是private 。struct所有的都是public。

- 可以将程序里所有的class全部替换成struct，它依旧可以很正常的运行。
- struct 是数据局结构是实现。class是对象的实现。建议当你设计的东西像数据的时候用struct。如果像是对象的话用class。
- “class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。
  
  
- 默认浮点数常亮类型是 double 占 8字节。如想要节省4字节就在末尾加f 变成 float。
- 默认整形常量是 int 占 4字节。可以末尾加 L 变成 long。
- When building 32-bit applications, **NSInteger** is a 32-bit integer. A 64-bit application treats NSInteger as a 64-bit integer.

- 字节对齐指令 #pragma pack(1)，表示 1 字节对齐。默认对齐字节数等于CPU位数。


> x86_64 和 arm64的地址空间。

- x86_64 栈顶 0x7f+后面12位，堆 0x1+后面8位。地址空间 0 ~ 0x7fff8个f。地址空间是 **47** 位。
- arm64 栈顶 0x1+后8位。堆 0x2+后面8位。地址空间是 **36** 位。

- 后三位都有特殊用处。

