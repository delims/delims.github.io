---
layout: post
author: delims
categories: iOS
---

- cin 和 cout 分别是 ostream 和 istream 的对象，是内置对象，是由标准库的开发者提前创建好的。

- endl 表示换行，功能等同于 "\n"。

- C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。

- C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。和 malloc() 一样，new 也是在堆区分配内存，必须手动释放

```
int *p = new int;  //分配1个int型的内存空间
delete p;  //释放内存

```

- new 操作符会根据后面的数据类型来推断所需空间的大小。如果希望分配一组连续的数据，可以使用 new[]，用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。

```
int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
```

- C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。

```
float d = 10.8;
void func(int n, float b=d+2.9, char c='@'){
    cout<<n<<", "<<b<<", "<<c<<endl;
}
```

- 使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。
- 使用初始化列表来初始化字段 Line::Line( double len): length(len)。

- 一个派生类继承了所有的基类方法，但下列情况除外：

1. 基类的构造函数、析构函数和拷贝构造函数。
2. 基类的重载运算符。
3. 基类的友元函数。

- **虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。
 
 - 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到**纯虚函数**。

```
	virtual int area() = 0;
```

= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。

- 数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。


- 默认情况下，在类中定义的所有项目都是私有的。
- C++ 接口是使用抽象类来实现的。
- 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。
- 抽象类不能被用于实例化对象。
- 抽象类的子类必须实现每一个**虚函数**。


- new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 

- 我用g++编译器发现C++ 检查数组越界。

# const 

-  int get() const{return i;} //get函数返回i的值，不需要对i进行修改，则可以用const修饰。防止在函数体内对i进行修改。
-  const成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数。

- const修饰的函数参数是指针时,代表在函数体内不能修改该指针所指的内容，起到保护作用。

```
//保护源字符串不被修改，若修改src则编译出错。  
void fun(const char * src, char * des)
{   
	strcpy(des,src);  
}  
```


- \# 和 ## 运算符，#处理成字符串，## 连接作用

> C++ 信号处理

| 信号 | 描述 |
| ---- | ---- | 
| SIGABRT | 程序的异常终止，如调用 abort |
| SIGFPE | 错误的算术运算导致，比如除以 0 |
| SIGILL | 检测到非法指令 |
| SIGINT | 程序终止（interrupt）信号 |
| SIGSEGV | 非法访问内存 |
| SIGTERM | 发送到程序的终止请求 |

- 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。

> static 关键字作用

1. 声明静态局部变量
2. 声明全局变量时限制作用域为本文件。
3. 修改类成员变量时，所有对象共享。

- 使用 thread_local 说明符声明的变量仅可在创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。



  