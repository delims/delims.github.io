---
layout: post
author: delims
categories: 网络
---

# UDP （User Datagram Protocol） 用户数据报协议

- 无连接，发送之前不需要建立连接。
- 不保证可靠交付。
- UDP面向报文，发送方的UDP对应用层交下来的报文，既不合并也不拆封，添加首部后直接交付网络层。接收方的UDP对网络层交上来的报文去掉UDP首部后直接交付给应用层。所以应用层在使用UDP时必须选择大小合适的报文。如果太长，网络层会分段导致降低网络层的效率，如果太短，网络层首部占比太大会浪费网络资源。
- UDP没有拥塞控制。当很多主机都向网络发送高速路实时视频流时，网络可能出现拥塞导致大家都无法正常接收。
- UDP支持一对一、一对多、多对一的和多对多的交互通信。
- UDP首部开销少，只有8B，分别是 源端口2B 目的端口2B 长度2B 校验和2B


# TCP (Transmission Control Protocol) 传输控制协议

- TCP是面向连接的运输层协议，应用程序使用TCP协议之前必须先建立TCP连接，数据传输完毕后必须释放已建立的TCP连接。
- 每一条TCP连接只有2个端点，TCP只支持一对一通信。
- TCP提供全双工通信。TCP允许通信双方的应用程序在任何时候都可以发送数据。
- TCP两端都设有发送缓存和接收缓存用来临时存放通信数据。
- TCP面向字节流，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。
- TCP和UDP在发送报文时所采用的方式完全不同。TCP并不关心应用进程一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送的报文长度是应用进程给出的）
- 如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些再传送。如果应用进程一次只发来一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去

- TCP连接的端点叫做套接字(socket),socket = IP:Port
- TCP连接 = {socket1,socket2} = {IP1:Port1,IP2:Port2}

## 停止等待协议

- 每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。 
- 设置一个超时计时器，如果在规定时间内没有收到对方确认，就重传。
- 自动重传请求ARQ (Automatic Repeat reQuest)。
- 发送放发完一个分组后保存副本，等收到确认后才清除。
- 接收方收到重复的分组后，丢掉，并且也发送一个确认。
- 这种协议信道利用率太低，只收到确认才继续发送，所以大部分时间信道是空闲的。

## 连续ARQ协议

- 像流水线一样传输，一次发送多个分组，不用发一个等一个。
- 发送方维持**发送窗口**，发送窗口是一个range，位于**发送窗口**内的分组可以连续发送。
- 发送方每收到一个确认就把窗口向前移动一个分组的位置。
- 接收方一般采用**累积确认**。例如收到确认编号100，表示编号100以及之前的所有分组都正常接收了。
- **优点**：不用每个分组都确认。
- **缺点**：发送方无法得知确认编号之后的分组有没有收到，只好重传。

## TCP首部

- 而TCP的全部功能都体现在它首部中各字段的作用。
- TCP首部20字节固定长度，后面有4n个字节根据需要而增加。

TCP报文段的首部字段依次为

| 字段 | 源端口 | 目的端口 | 序号 | 确认号 | 偏移保留控制 | 窗口 | 校验和 | 紧急指针 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 长度 | 2 | 2 | 4 | 4 | 2 | 2 | 2 | 2 | 




